Components
==========

This page describes the main internal components, and it can be ignored by regular users.

Core Transformations
--------------------

When imported, ``blueetl`` automatically registers itself as a Pandas accessor, providing some custom methods to every Pandas DataFrame, Series, or Index.
These helper functions can be accessed using the ``etl`` namespace.

For example, if ``df`` is the variable containing a DataFrame, you can use ``df.etl.q()`` to call the ``q`` method, that provides an alternative way to query and filter the DataFrame.

The list of available methods can be found in the API documentation for ``blueetl-core``.

For more information about Pandas custom accessors, see the `official documentation <https://pandas.pydata.org/pandas-docs/stable/development/extending.html#registering-custom-accessors>`__.


Simulation Campaign Configuration
---------------------------------

The class ``blueetl.campaign.config.SimulationCampaign`` is used to load a Simulation Campaign from a configuration file generated by ``bbp-workflow``.

Internally, it stores the list of simulations and their attributes as a Pandas DataFrame.


Report Analysis
---------------

The class ``blueetl.analysis.MultiAnalyzer`` can be initialized with a specific configuration file, that should provide:

- the path to the simulation campaign configuration
- the parameters needed to extract the report from the simulations
- the parameters needed to calculate the features from the extracted report


Repository (Extraction)
-----------------------

The class ``blueetl.repository.Repository`` is responsible for the extraction of the report from the simulations.

It exposes the extracted data as objects wrapping the following Pandas DataFrames, that can be accessed directly if needed:

- simulations
- neurons
- neuron_classes
- trial_steps
- windows
- report


FeaturesCollection
------------------

The class ``blueetl.features.FeaturesCollection`` is responsible for the calculation of the features, using to the given configuration.

The configuration should specify how the report should be grouped and the name of a user defined function that's called for each group.

One or more dataframes of features can be produced, and they will be exposed by wrapper objects similar to the ones used for the repository.
